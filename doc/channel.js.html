<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Source: channel.js</title>
    
    
    
    
    
    <meta property="og:title" content=""/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jaguar.css">
    
    
    <script>
    var config = {"monospaceLinks":true,"cleverLinks":true,"default":{"outputSourceFiles":true},"applicationName":"MikroNode","disqus":"","googleAnalytics":"","openGraph":{"title":"","type":"website","image":"","site_name":"","url":""},"meta":{"title":"","description":"","keyword":""},"linenums":false};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="index.html">MikroNode</a></h3>

    <div class="search">
        <input id="search" type="text" class="form-control input-sm" placeholder="Search Documentations">
    </div>
    <ul class="list">
    
        <li class="item" data-name="mikronode">
            <span class="title">
                <a href="mikronode.html">mikronode</a>
                
                <span class="static">static</span>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="mikronode.getConnection"><a href="mikronode.html#.getConnection">getConnection</a></li>
            
                <li data-name="mikronode.parseItems"><a href="mikronode.html#.parseItems">parseItems</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="mikronode.Channel">
            <span class="title">
                <a href="mikronode.Channel.html">mikronode.Channel</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="mikronode.Channel#clearEvents"><a href="mikronode.Channel.html#clearEvents">clearEvents</a></li>
            
                <li data-name="mikronode.Channel#closed"><a href="mikronode.Channel.html#closed">closed</a></li>
            
                <li data-name="mikronode.Channel#closeOnDone"><a href="mikronode.Channel.html#closeOnDone">closeOnDone</a></li>
            
                <li data-name="mikronode.Channel#closing"><a href="mikronode.Channel.html#closing">closing</a></li>
            
                <li data-name="mikronode.Channel#connection"><a href="mikronode.Channel.html#connection">connection</a></li>
            
                <li data-name="mikronode.Channel#id"><a href="mikronode.Channel.html#id">id</a></li>
            
                <li data-name="mikronode.Channel#lastCommand"><a href="mikronode.Channel.html#lastCommand">lastCommand</a></li>
            
                <li data-name="mikronode.Channel#running"><a href="mikronode.Channel.html#running">running</a></li>
            
                <li data-name="mikronode.Channel#saveBuffer"><a href="mikronode.Channel.html#saveBuffer">saveBuffer</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            <span class="subtitle">Typedefs</span>
            
                <li data-name="mikronode.Channel.writeCallback"><a href="mikronode.Channel.html#.writeCallback">writeCallback</a></li>
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="mikronode.Channel#close"><a href="mikronode.Channel.html#close">close</a></li>
            
                <li data-name="mikronode.Channel#finalize"><a href="mikronode.Channel.html#finalize">finalize</a></li>
            
                <li data-name="mikronode.Channel#write"><a href="mikronode.Channel.html#write">write</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            <span class="subtitle">Events</span>
            
                <li data-name="mikronode.Channel#event:close"><a href="mikronode.Channel.html#event:event:close">event:close</a></li>
            
                <li data-name="mikronode.Channel#event:done"><a href="mikronode.Channel.html#event:event:done">event:done</a></li>
            
                <li data-name="mikronode.Channel#event:error"><a href="mikronode.Channel.html#event:event:error">event:error</a></li>
            
                <li data-name="mikronode.Channel#event:timeout"><a href="mikronode.Channel.html#event:event:timeout">event:timeout</a></li>
            
                <li data-name="mikronode.Channel#event:trap"><a href="mikronode.Channel.html#event:event:trap">event:trap</a></li>
            
            </ul>
        </li>
    
        <li class="item" data-name="mikronode.Connection">
            <span class="title">
                <a href="mikronode.Connection.html">mikronode.Connection</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="mikronode.Connection#closeOnDone"><a href="mikronode.Connection.html#closeOnDone">closeOnDone</a></li>
            
                <li data-name="mikronode.Connection#host"><a href="mikronode.Connection.html#host">host</a></li>
            
                <li data-name="mikronode.Connection#password"><a href="mikronode.Connection.html#password">password</a></li>
            
                <li data-name="mikronode.Connection#port"><a href="mikronode.Connection.html#port">port</a></li>
            
                <li data-name="mikronode.Connection#status"><a href="mikronode.Connection.html#status">status</a></li>
            
                <li data-name="mikronode.Connection#timeout"><a href="mikronode.Connection.html#timeout">timeout</a></li>
            
                <li data-name="mikronode.Connection#user"><a href="mikronode.Connection.html#user">user</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            <span class="subtitle">Typedefs</span>
            
                <li data-name="mikronode.Connection.connectCallback"><a href="mikronode.Connection.html#.connectCallback">connectCallback</a></li>
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="mikronode.Connection.parseItems"><a href="mikronode.Connection.html#.parseItems">parseItems</a></li>
            
                <li data-name="mikronode.Connection#closeChannel"><a href="mikronode.Connection.html#closeChannel">closeChannel</a></li>
            
                <li data-name="mikronode.Connection#connect"><a href="mikronode.Connection.html#connect">connect</a></li>
            
                <li data-name="mikronode.Connection#getChannel"><a href="mikronode.Connection.html#getChannel">getChannel</a></li>
            
                <li data-name="mikronode.Connection#getCommandPromise"><a href="mikronode.Connection.html#getCommandPromise">getCommandPromise</a></li>
            
                <li data-name="mikronode.Connection#getConnectPromise"><a href="mikronode.Connection.html#getConnectPromise">getConnectPromise</a></li>
            
                <li data-name="mikronode.Connection#openChannel"><a href="mikronode.Connection.html#openChannel">openChannel</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            <span class="subtitle">Events</span>
            
                <li data-name="mikronode.Connection#event:close"><a href="mikronode.Connection.html#event:event:close">event:close</a></li>
            
                <li data-name="mikronode.Connection#event:error"><a href="mikronode.Connection.html#event:event:error">event:error</a></li>
            
                <li data-name="mikronode.Connection#event:timeout"><a href="mikronode.Connection.html#event:event:timeout">event:timeout</a></li>
            
                <li data-name="mikronode.Connection#event:trap"><a href="mikronode.Connection.html#event:event:trap">event:trap</a></li>
            
            </ul>
        </li>
    
        <li class="item" data-name="mikronode.Trap">
            <span class="title">
                <a href="mikronode.Trap.html">mikronode.Trap</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="mikronode.Trap#channel"><a href="mikronode.Trap.html#channel">channel</a></li>
            
                <li data-name="mikronode.Trap#channelId"><a href="mikronode.Trap.html#channelId">channelId</a></li>
            
                <li data-name="mikronode.Trap#errors"><a href="mikronode.Trap.html#errors">errors</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="mikronode.TrapError">
            <span class="title">
                <a href="mikronode.TrapError.html">mikronode.TrapError</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="mikronode.TrapError#category"><a href="mikronode.TrapError.html#category">category</a></li>
            
                <li data-name="mikronode.TrapError#message"><a href="mikronode.TrapError.html#message">message</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
    </ul>
</div>
    <div class="main">
        <h1 class="page-title" data-filename="channel.js.html">Source: channel.js</h1>
        


    
    <section>
        <article>
            <pre class="prettyprint source "><code>var events = require('events');
var crypto = require('crypto');
var util = require('util');
var dbg = require('debug');
var utils = require('./utils');

module.exports = (function() {

	var debugChannel = dbg('mikronode:channel');
	var debugChannelData = dbg('mikronode:channel:data');

	var _ = require('private-parts').createKey();

	/**
	 * writeCallback
	 * @callback mikronode.Channel.writeCallback
	 * @param {Channel}
	 */

	/**
	 * Emitted when a command has finished successfully.
	 * @event mikronode.Channel#event:done
	 * @property {(string|string[])} data - The data returned by the channel
	 * @property {Channel} channel - The channel originating the event Fatal event.
	 */
	/**
	 * Emitted when a non-recoverable error has occurred on the socket. No further commands
	 * can be processed on any channel.
	 * @event mikronode.Channel#event:error
	 * @property {error} error - The error object
	 * @property {Channel} channel - The channel originating the event
	 */
	/**
	 * Emitted when a socket has been idle too long.
	 * @event mikronode.Channel#event:timeout
	 * @property {string} message - 'Socket Timeout'
	 * @property {boolean} socketStillOpen - If true, communications can continue
	 * @property {Channel} channel - The channel originating the event
	 */
	/**
	 * Emitted when the channel is closed either by an explicit call to
	 * {@link mikronode.Channel#close} or when the channel is closed automatically via
	 * {@link mikronode.Channel#closeOnDone}
	 * @event mikronode.Channel#event:close
	 * @property {Channel} channel - The channel originating the event
	 */
	/**
	 * Emitted when a command has failed. Subsequent commands may succeed.
	 * @event mikronode.Channel#event:trap
	 * @property {mikronode.Trap} trap - The trap object
	 */

	/**
	 * Channel (should not be instantiated directly)
	 * @exports mikronode.Channel
	 * @implements {EventEmitter}
	 * @class
	 * @param {number} id
	 * @param {mikronode.Connection} conn
	 * @fires mikronode.Channel#event:done
	 * @fires mikronode.Channel#event:trap
	 * @fires mikronode.Channel#event:error
	 * @fires mikronode.Channel#event:timeout
	 * @fires {mikronode.Channel#event:close}
	 */
	function Channel(id, conn) {
		debugChannel('Opening channel: ' + id);

		/**
		 * Channel ID
		 * @public
		 * @readonly
		 * @instance
		 * @member {number} id
		 * @memberof mikronode.Channel
		 */
		utils.createProperty(this, 'id', id);
		/**
		 * Connection
		 * @public
		 * @readonly
		 * @instance
		 * @member {mikronode.Connection} connection
		 * @memberof mikronode.Channel
		 */
		utils.createProperty(this, 'connection', conn);
		/**
		 * @public
		 * @readonly
		 * @instance
		 * @member {boolean} running
		 * @memberof mikronode.Channel
		 */
		utils.createProperty(this, 'running', false, false, _);
		/**
		 * @public
		 * @readonly
		 * @instance
		 * @member {boolean} closing
		 * @memberof mikronode.Channel
		 */
		utils.createProperty(this, 'closing', false, false, _);
		/**
		 * @public
		 * @readonly
		 * @instance
		 * @member {boolean} closed
		 * @memberof mikronode.Channel
		 */
		utils.createProperty(this, 'closed', false, false, _);

		/**
		 * Clear event listeners on done
		 * @public
		 * @instance
		 * @member {boolean} clearEvents
		 * @memberof mikronode.Channel
		 */
		this.clearEvents = false;

		/**
		 * Save each line received in a buffer and pass the entire buffer to the done event.
		 * Otherwise the done event will not get all the lines, only the last line. This is
		 * handy when following trailing output from a listen command, where the data could
		 * be endless.
		 * @public
		 * @instance
		 * @member {boolean} saveBuffer
		 * @memberof mikronode.Channel
		 */
		this.saveBuffer = true;

		/**
		 * Close channel on done
		 * @public
		 * @instance
		 * @member {boolean} closeOnDone
		 * @memberof mikronode.Channel
		 */
		this.closeOnDone = false;

		/**
		 * @public
		 * @readonly
		 * @instance
		 * @member {string[]} lastCommand
		 * @memberof mikronode.Channel
		 */
		this.lastCommand = [];

		/**
		 * @private
		 * @instance
		 * @member {mikronode.Channel.writeCallback} writeCallback
		 * @memberof mikronode.Channel
		 */
		_(this).writeCallback = null;
		/**
		 * @private
		 * @instance
		 * @member {array} packet
		 * @memberof mikronode.Channel
		 */
		_(this).packet = [];
		/**
		 * @private
		 * @instance
		 * @member {array} commands
		 * @memberof mikronode.Channel
		 */
		_(this).commands = [];
		/**
		 * @private
		 * @instance
		 * @member {array} buffer
		 * @memberof mikronode.Channel
		 */
		_(this).buffer = [];

		/* We want connection errors to propogate down to
		 * the channel so they can be caught by a channel promise
		 */
		var _this = this;

		/* A 'error' event is thrown by Socket
		 * and are non-recoverable so we force close the channel. 
		 */
		conn.once('error', this.errorListener);

		/* A 'timeout' event is thrown by Socket
		 * but they are recoverable. If Connection has closed
		 * the Socket, we'll close the channel.  Otherwise, just
		 * notify receivers and let them decide what to do.
		 */
		conn.on('timeout', this.timeoutListener);
	}
	util.inherits(Channel, events.EventEmitter);

	Channel.prototype.errorListener = function errorListener(err) {
		debugChannel('Channel %s caught Connection Error: %o', this.id, this.connection);
		this.emit('error', err, this);
		this.close(true);
	};

	Channel.prototype.timeoutListener = function timeoutListener(message, socketStillOpen) {
		debugChannel('Channel %s caught Timeout', this.id);
		this.emit('timeout', message, socketStillOpen, this);
		if (!socketStillOpen) {
			this.close(true);
		}
	};

	/**
	 * Writes data to the channel
	 * @param {(string|string[])} data - Can be a single string with the command and
	 *           optional parameters separated by '\n' or an array of strings with the
	 *           command in the first position and the parameters in the rest.
	 * @param {(object|string[])} [parameters] - If the first parameter is a command
	 *           string, this object will be treated as the parameters for the command.
	 *           &lt;p>
	 *           It can be an array or strings...
	 * 
	 * &lt;pre>
	 * ['name=value','name=value'...]
	 * &lt;/pre>
	 * 
	 * or an Object...
	 * 
	 * &lt;pre>
	 * {'name': 'value', 'name': 'value'...}
	 * &lt;/pre>
	 * 
	 * @param {mikronode.Channel.writeCallback} [writeCallback] - This will be called just
	 *           before write actually writes the data to the connection.
	 */
	Channel.prototype.write = function write(d, parameters, writeCallback) {
		if (_(this).closing) {
			return;
		}

		if (d) {
			if (typeof (d) === 'string') {
				d = d.split("\n");
			}
			if (typeof parameters !== 'function') {
				if (Array.isArray(parameters)) {
					Array.prototype.push.apply(d, parameters);
				} else if (parameters instanceof Object) {
					Object.keys(parameters).forEach(function(k) {
						d.push(k + '=' + parameters[k]);
					});
				}
			} else if (writeCallback === undefined) {
				writeCallback = parameters;
			}
			if (Array.isArray(d) &amp;&amp; d.length) {
				_(this).buffer = _(this).buffer.concat(d);
			} else {
				return;
			}
		} else {
			debugChannel('Channel %s write: empty arg.', this.id);
		}

		if (_(this).running) {
			this.lastCommand = _(this).buffer;
			if (debugChannelData.enabled) {
				debugChannelData('Channel %s running: pushing command %o', this.id, this.lastCommand);
			} else {
				debugChannel('Channel %s running: pushing command', this.id);
			}
			_(this).commands.push([ _(this).buffer, writeCallback ]);
			_(this).buffer = [];
		} else {
			this.lastCommand = _(this).buffer;
			var b = _(this).buffer;
			_(this).running = true;
			this.saveBuffer = true;
			_(this).buffer = [];
			b.push('.tag=' + this.id);
			if (writeCallback) {
				writeCallback(this);
			}
			if (debugChannelData.enabled) {
				debugChannelData('Channel %s idle: writing %o', this.id, this.lastCommand);
			} else {
				debugChannel('Channel %s idle: writing', this.id);
			}
			this.connection._write(b); // Send command.
		}
	};

	/**
	 * Called when connection gets 'done'
	 * @private
	 * @param {(string|string[])} data
	 */
	Channel.prototype._done = function _done(data, trap) {
		if (trap) {
			debugChannel('Channel %s trap: %o', this.id, trap);
			this.emit('trap', trap, this);
		} else {
			var p = _(this).packet;
			_(this).packet = [];
			if (!p.length) {
				p = [ data ];
			} else if (p[p.length - 1] !== data) {
				p.push(data);
			}

			if (debugChannelData.enabled) {
				debugChannelData('Channel %s done: %o', this.id, p);
			} else {
				debugChannel('Channel %s done', this.id);
			}

			this.emit('done', p, this);
		}

		if (this.clearEvents) {
			this.removeAllListeners('done');
			this.removeAllListeners('data');
			this.removeAllListeners('read');
		}
		_(this).running = false;
		if (_(this).commands.length) {
			var c = _(this).commands.shift();
			var cl = _(this).closing;
			_(this).closing = false;
			debugChannel('Channel %s more commands', this.id);
			this.write(c[0], {}, c[1]);
			_(this).closing = cl;
		} else if (_(this).closing || this.closeOnDone) {
			this.close();
		}
	};

	/**
	 * Called when connection gets 'data'
	 * @private
	 * @param {(string|string[])} data
	 */
	Channel.prototype._data = function _data(data) {
		if (debugChannelData.enabled) {
			debugChannelData('Channel %s data: %o', this.id, data);
		} else {
			debugChannel('Channel %s data', this.id);
		}

		if (this.saveBuffer) {
			_(this).packet.push(data);
		}
		this.emit('data', [ data ], this);
		this.emit('read', [ data ], this);
	};

	/**
	 * Closes the channel This will close the connection if
	 * {@link mikronode.Connection#closeOnDone} was set and this was the last channel to
	 * close.
	 * @public
	 * @param {boolean} force - Force close even of there are other commands pending.
	 *           Otherwise mark the channel as 'closing' which will prevent new commands
	 *           from being started but will let queued ones finish.
	 */
	Channel.prototype.close = function close(force) { // Close _(this) channel.
		_(this).closing = true;
		if (_(this).closed || (!force &amp;&amp; (_(this).commands.length || _(this).running))) {
			debugChannel('Channel %s closing deferred', this.id);
			return;
		}
		debugChannel('Channel %s closing.  Forced: %s', this.id, force ? 'true' : 'false');
		if (_(this).running) {
			try {
				debugChannel('Channel %s sending cancel', this.id);
				this.connection._write([ '/cancel', '=tag=' + this.id ]);
			} catch (err) {
				debugChannel('Error sending /cancel', err.stack);
			}
		}

		this.connection.removeListener('error', this.errorListener).removeListener('timeout', this.timeoutListener);

		debugChannel('Channel %s closed', this.id);
		_(this).closed = true;
		this.emit('close', this);
		this.removeAllListeners();
	};

	/**
	 * Calls {@link mikronode.Channel#close}(false)
	 * @public
	 */
	Channel.prototype.finalize = function finalize() {
		debugChannel('Channel %s finalize', this.id);
		if (!_(this).closing) {
			this.close();
		}
	};

	return Channel;
})();
</code></pre>
        </article>
    </section>






        

        <footer>
            Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Dec 25 2015 20:03:32 GMT-0700 (MST)
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/main.js"></script>
</body>
</html>
